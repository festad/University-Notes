\documentclass{beamer}
% english language
\usepackage[english]{babel}

% tables
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{svg}
\usepackage{xcolor}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usetheme{Madrid}

% unibs color #3d5895
% \definecolor{unibs}{RGB}{61,88,149}
\definecolor{unibs}{HTML}{3d5895}

\definecolor{offset}{HTML}{ff1a1a}
\definecolor{reading_offset}{HTML}{1a40ff}


\setbeamercolor{palette primary}{fg=white, bg=unibs}
\setbeamercolor{palette secondary}{fg=white, bg=unibs}
\setbeamercolor{palette tertiary}{fg=white, bg=unibs}
\setbeamercolor{palette quaternary}{fg=white, bg=unibs}
\setbeamercolor{structure}{fg=unibs} % itemize, enumerate, etc
\setbeamercolor{section in toc}{fg=unibs} % TOC sections






\title{Exact Cover}
\author{Denis Festa}
\date{\today}

\begin{document}


% \frame{\titlepage}
% Title page with logo
\begin{frame}
    % \centering
    % logo on title page
    \titlepage
    \centering
    \includegraphics[width=0.2\linewidth]{unibs-circ-logo.pdf}
\end{frame}

% Logo on every slide at the top-right corner
\logo{\includegraphics[width=0.1\linewidth]{unibs_logo.pdf}}

% \begin{frame}
%     \frametitle{Table of contents}
%     \tableofcontents
% \end{frame}

\section{Introduction}
\begin{frame}
    \frametitle{Introduction}

    The following presentation provides a self-contained report on the 
    implementation of the exact cover problem provided by prof. Marina Zanella
    (University of Brescia, Italy).
    The language of choice is Python for its simplicity and readability.
    The code is available at \url{https://www.kaggle.com/code/denisfesta/exact-cover-problem}.
    The following points discuss:
    \begin{itemize}
        \item the choice of the data structures for the algorithm in its basic form;
        \item the exploration of the solutions to different problems;
        \item the comparison between loading portions of the file and loading the 
            whole file;
        \item the comparison between the basic algorithm and the \textit{plus} 
            algorithm;
        \item the application of the algorithm to the sudoku problem.
    \end{itemize}

\end{frame}

\section*{Data structures}

\begin{frame}
    \frametitle{Data structures}

    To pursue the goal of implementing the algorithm, the matrices A and B need
    to be stored in an appropriate data structure. Since the matrices contain
    only 0s and 1s, the first idea might be to store boolean values instead
    of integers, however, using 
    % True and False written in code style
    \texttt{True} and \texttt{False} gives no advantage.
    One popular library that provides boolean arrays and matrices is
    \texttt{numpy}, which I compare with the less popular \texttt{bitarray}
    library and show the results in figures (\ref{fig:mem_array}) and 
    (\ref{fig:mem_matrix}).
    The elements of a \texttt{numpy} array or matrix occupy less memory than
    the elements of a \texttt{bitarray} array or matrix, however,
    the \texttt{numpy} variable storing the array occupies more memory 
    than the \texttt{bitarray} variable storing the array.
    Given the absence of matrix operations, I don't see any 
    particular advantage in using \texttt{numpy} over \texttt{bitarray}.
    
\end{frame}

\begin{frame}
        % picture "mem_array.png" here
        \begin{figure}
            \centering
            \includegraphics[width=0.6\textwidth]{mem_array.png}
            % \caption{}
            \label{fig:mem_array}
        \end{figure}
\end{frame}

\begin{frame}
        % picture "mem_matrix.png" here
        \begin{figure}
            \centering
            \includegraphics[width=0.55\textwidth]{mem_matrix.png}
            % \caption{}
            \label{fig:mem_matrix}
        \end{figure}
\end{frame}

\begin{frame}
    I tried to profile the code with \texttt{memory-profiler} 
    to find whether the memory occupation
    advantages
    we expect to gain from choosing one data structure over the other
    are actually realized, but I couldn't see any significant difference
    in the memory usage while executing the code, I guess it's because
    the memory required to store the matrices is negligible compared
    to the memory required to store the set of solutions, the set of explored nodes
    and the stack of the recursive calls.
\end{frame}

\section*{Exploring the solutions}

\begin{frame}
    \frametitle{Exploring the solutions}
    Different choices of the cardinality of the domain (columns of the matrix A) and
    the number of sets (rows of the matrix A, rows and columns of the matrix B) 
    lead to different values of:
    \begin{itemize}
        \item the number of solutions found;
        \item the number of explored nodes to find the solutions;
        \item the time required to find the solutions.
    \end{itemize}
    In the following slides I show the values of these quantities for different
    autmatically generated instances of the problem, for time constraints I kept the 
    number of sets in a range between 20 and $\sim400$ and the cardinality of the domain
    in a range between 5 and 14.
\end{frame}

\begin{frame}{Solutions found}
    It's intuitive that the number of solutions found increases
    with the number of sets and decrease with the cardinality of the domain.
    In this case the intuition is confirmed by the solutions found (\ref{fig:sol_5x5}) (at least, those
    found in the chosen dimensions of the problem).
\end{frame}

\begin{frame}
    \begin{figure}
        \centering
        \includegraphics[width=0.6\textwidth]{sol_5x5.pdf}
        % \caption{}
        \label{fig:sol_5x5}
    \end{figure}
\end{frame}

\begin{frame}{Explored nodes}
    It might seem intuitive that, similarly to the previous case, the number of explored nodes
    increases with the number of sets and decreases with the cardinality of the domain,
    however, the same problems that were solved in the previous case display a different
    and less intuitive behaviour in this case (\ref{fig:explored_5x5}).
    The interpretation of this behaviour is that the algorithm has to work harder,
    that is to explore more nodes, to find the solutions for more complex problems, that
    is those problems with a higher number of rows and a higher number of columns.
    Why, fixed the number of rows, a small number of columns implies a higher
    number of explored nodes? I don't know.
\end{frame}

\begin{frame}
    \begin{figure}
        \centering
        \includegraphics[width=0.6\textwidth]{explored_5x5.pdf}
        % \caption{}
        \label{fig:explored_5x5}
    \end{figure}
\end{frame}

\begin{frame}{Explorable nodes}
    The implemented algorithm chooses to prune the nodes in the tree
    that cannot lead to a plausible solution.
    If the algorithm were to explore all the possible nodes, then for the 
    $i$-th set the number of nodes to explore would be $2^i$,
    hence, if $n$ is the number of sets (rows of A),
    the number of nodes to explore would be $\sum_{i=0}^{n-1} 2^i = 2^n - 1$.

    In figure (\ref{fig:explored_vs_explorable_5x5}) the enormous difference
    between the number of explored nodes and the number of explorable nodes is shown.
    the number of explorable nodes is not exactly $2^n - 1$ because
    the actual computation to represent the explorable nodes is 
    $\sum_{i\in\mathcal{E}}2^i$ where $\mathcal{E}$ is the set of
    explorable  indices
    pointing to rows of A different from an all-zero row (which would be,
    by definition, compatible with any other row).
\end{frame}

\begin{frame}
    \begin{figure}
        \centering
        \includegraphics[width=0.6\textwidth]{explored_vs_explorable_5x5.pdf}
        % \caption{}
        \label{fig:explored_vs_explorable_5x5}
    \end{figure}
\end{frame}

\begin{frame}{Loading portions}
    The problem to solve might require a huge matrix A,
    to prevent the computer from running out of memory
    one of the possible solutions is to load portions of the matrix
    and solve the problem for each portion, growing incrementally
    the set of solutions.
    What is expected is that loading the whole matrix and solving
    at once is faster than loading portions of the matrix.
    The results shown in figure (\ref{fig:load_portions_a}) and 
    (\ref{fig:load_portions_b}) say something more.
    What can be noticed is that the greatest advantage that comes
    from decreasing the dimension of the chunk of loaded rows is gained
    when the dimension is small, then there is no clear advantage,
    sometimes loading a greater number of rows at once is faster
    and sometimes it's slower.
\end{frame}

\begin{frame}
    \begin{figure}
        \centering
        \includegraphics[width=0.75\textwidth]{loadable_rows_time_diff.pdf}
        % \caption{}
        \label{fig:load_portions_a}
    \end{figure}
\end{frame}

\begin{frame}
    \begin{figure}
        \centering
        \includegraphics[width=0.75\textwidth]{loadable_rows_time_diff_rev.pdf}
        % \caption{}
        \label{fig:load_portions_b}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{figure}
        \centering
        \includegraphics[width=0.75\textwidth]{loadable_rows_time_diff_shuffled.pdf}
        % \caption{}
        \label{fig:plus_star_5x5}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{figure}
        \centering
        \includegraphics[width=0.75\textwidth]{base_star_5x5.pdf}
        % \caption{}
        \label{fig:base_star_5x5}
    \end{figure}
\end{frame}


\begin{frame}
I manually tried to test the behaviour of the algorithm for
different dimensions of the chunk on a larger problem (1000 rows
and 15 columns) and 
% when loading 1 row at a time the algorithm takes 24.5 seconds, 
% when loading 2 rows it takes 15.3 seconds,
% when loading 3 rows it takes 12.3 seconds,
% when loading 5 rows it takes 9.7 seconds, 
% when loading 10 rows it takes 7.9 seconds,
% when loading 20 rows it takes 6.9 seconds,
% when loading 50 rows it takes 6.5 seconds,
% when loading 100 rows it takes 6.5 seconds,
% when loading 400 rows it takes 6.6 seconds.
\begin{itemize}
    \item when loading 1 row at a time the algorithm takes 24.5 seconds;
    \item when loading 2 rows it takes 15.3 seconds;
    \item when loading 3 rows it takes 12.3 seconds;
    \item when loading 5 rows it takes 9.7 seconds;
    \item when loading 10 rows it takes 7.9 seconds;
    \item when loading 20 rows it takes 6.9 seconds;
    \item when loading 50 rows it takes 6.5 seconds;
    \item when loading 100 rows it takes 6.5 seconds;
    \item when loading 400 rows it takes 6.6 seconds;
    \item when loading 900 rows it takes 7.1 seconds.
    \item when loading 1000 rows it takes 7.6 seconds
\end{itemize}
\end{frame}

\begin{frame}{More or less 1s}
    For a better comprehension of how the number of explored nodes 
    depends on the structure of the problem, one possibility
    is to generate random exact cover problems varying the sparsity
    of the matrix $A$.
    The intuition is that the more 1s there are in each row
    of the matrix $A$, the more difficult it is for the problem
    to have different rows that are compatible,
    hence, the more difficult it is for the algorithm to find
    the solutions and the more nodes it has to explore.
    The more 0s there are in each row of the matrix $A$, the more
    likely it is for the problem to find solutions,
    each partition will contain more rows since each row contains
    fewer 1s, hence, the algorithm will have less difficulties
    in finding the solutions and will explore less nodes.
    The figures (\ref{fig:explored_nodes_prob}), (\ref{fig:solutions_prob})
    and (\ref{fig:time_to_solve_prob}) show the results of the experiments
    and, the larger the number of columns (lower rows), the more
    the more our intuition is confirmed.
\end{frame}

\begin{frame}{}
    \begin{figure}
        \centering
        \includegraphics[width=0.75\textwidth]{explored_nodes_prob.pdf}
        % \caption{}
        \label{fig:explored_nodes_prob}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{figure}
        \centering
        \includegraphics[width=0.75\textwidth]{solutions_prob.pdf}
        % \caption{}
        \label{fig:solutions_prob}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{figure}
        \centering
        \includegraphics[width=0.75\textwidth]{time_to_solve_prob.pdf}
        % \caption{}
        \label{fig:time_to_solve_prob}
    \end{figure}
\end{frame}

\begin{frame}{EC wrapper}
    In the following slides the mechanism wrapping the EC algorithm
    is presented. 
    The idea is to load a portion of the matrix A, execute the EC algorithm
    and store the solutions found in a set, then load the next portion of
    the matrix A, execute the EC algorithm and grow the set of solutions.
    The important thing to keep in mind is that when the algorithm 
    is executing on a portion of the matrix A, say from row $i$ to row $j$,
    the rows from $0$ to $i-1$ are not immediately available, they will
    be read from within the EC algorithm, again in portions.
    % color for offset -> #FF1A1A
    % color for reading offset -> #1A40FF
    This explains the need for two variables:
    \textcolor{offset}{offset} and the \textcolor{reading_offset}{reading offset}
    (the same colors will be used in the schema and the animation to follow.)
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item \textcolor{offset}{offset} is the index of the first row of the portion
            of the matrix A that has been passed to the EC algorithm from outside
        \item \textcolor{reading_offset}{reading offset} is the index of the first row of the portion
            of the matrix A that is being read by the EC algorithm,
            reading offset will always start from 0 and will be incremented until
            the rows are read from 0 to the last row of the portion of the matrix A 
            that has been passed to the EC algorithm from outside.
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{algorithmic}
        % \Function{CalculateFactorial}{$n$}
        %     \If {$n \leq 1$}
        %         \State \Return 1
        %     \Else
        %         \State $result \gets 1$
        %         \For{$i \gets 1$ to $n$}
        %             \State $result \gets result \times i$
        %         \EndFor
        %         \State \Return $result$
        %     \EndIf
        % \EndFunction
        % \State $x \gets 5$
        % \State $y \gets \Call{CalculateFactorial}{x}$
        % \State \textbf{print} $y$
        \Function{IncrementalExactCover}{$filename$}
            \State $rows \gets \Call{GetRows}{filename}$
            \State $columns \gets \Call{GetColumns}{filename}$
            \State $B \gets \Call{zeros}{rows, columns}$
            \State $COV \gets \Call{set}{\emptyset}$
            \State $offset \gets 0$
            \While{true}
                \State $A \gets \Call{GetPortionOfA}{filename, offset, loadableRows}$
                % If A is empty, break
                \If{$A$ is empty}
                    \State \textbf{break}
                \EndIf
                \State \Call{EC}{$A$, $B$, $COV$, $offset$, $filename$, $loadableRows$}
            \EndWhile
            \State \Return $COV$
        \EndFunction
    \end{algorithmic}
\end{frame}

% \begin{frame}{}
%     \begin{algorithmic}[1]
%         \Function{IncrementalProcess}{$A$, $B$, $COV$, $offset$, $filename$, $loadable\_rows$}
%             \State $new\_COV$ = \Call{EC}{$A$, $B$, $offset$, $filename$, $loadable\_rows$}
%             \State $COV \gets COV \cup new\_COV$
%         \EndFunction
%     \end{algorithmic}
% \end{frame}


\begin{frame}{}
    \scriptsize
    \begin{algorithmic}
        \Function{EC}{$A$, $B$, $COV$, $offset$, $filename$, $loadableRows$}
            \State $N \gets \Call{rows}{A}$ \Comment{Number of rows of A}
            \State $M \gets \Call{columns}{A}$ \Comment{Number of columns of A}
            \For {$i \gets 0$ to $N-1$}
                % row = A[i]
                \State $row \gets A[i]$     
                \If {$\Call{sum}{row} = 0$} \Comment{If the row is all 0s}
                    \For {$t \gets 0$ to $N-1$} \Comment{set the relative
                    row and column of B to 0}
                        \State $B[t][i+offset] \gets 0$
                        \State $B[i+offset][t] \gets 0$
                    \EndFor
                    \State \textbf{continue}  
                \EndIf  
                    
                    % if sum(row_data) == M:
                    % for t in range(N):
                    %     B[t][i+offset] = 0
                    %     B[i+offset][t] = 0
                    % COV.add((offset + i,))
                    % continue    
                \If {$\Call{sum}{row} = M$} \Comment{If the row is all 1s}
                    \For {$t \gets 0$ to $N-1$} \Comment{set the relative
                    row and column of B to 0}
                        \State $B[t][i+offset] \gets 0$
                        \State $B[i+offset][t] \gets 0$
                    \EndFor
                    \State $COV \gets COV \cup \{(offset + i,)\}$
                    \State \textbf{continue}
                \EndIf

                \State $readingOffset \gets 0$

                \State \Call{WhileCycle}{$A$, $B$, $COV$, $offset$, $filename$, $loadableRows$, $i$, $readingOffset$}
            \EndFor
        \EndFunction
    \end{algorithmic}
\end{frame}

\begin{frame}{}
    \tiny
    \begin{algorithmic}
        \Function{WhileCycle}{$A$, $B$, $COV$, $offset$, $filename$, $loadableRows$, $i$, $readingOffset$}

            \While{$readingOffset < i + offset$}
                \State $oldA \gets \Call{GetPortionOfA}{filename, readingOffset, loadableRows}$

                % \State $j \gets 0$ to $\Call{min}{\Call{rows}{oldA}, i + offset - readingOffset} - 1$
                \State $numRows \gets \Call{rows}{oldA}$
                \State $endVal \gets \Call{min}{numRows, i + offset - readingOffset} - 1$
                \For {$j \gets 0$ to $endVal$}
                    \State $oldRow \gets oldA[j]$

                    \If {$\Call{sum}{oldRow} \in \{0, M\}$}
                        \State \textbf{continue}
                    \EndIf
                    
                    \If {$\Call{intersect}{oldRow, row}$}
                        \State $B[j + readingOffset][i + offset] \gets 0$
                    \Else
                        \State $I \gets (offset + i, j + readingOffset)$
                        \State $U \gets \Call{union}{oldRow, row}$
                        \If {$\Call{sum}{U} = M$}
                            \State $COV \gets COV \cup \{I\}$
                            \State $B[j + readingOffset][i + offset] \gets 0$
                        \Else
                            \State $B[j + readingOffset][i + offset] \gets 1$
                            % \State $intersect \gets \{k \mid k \in \{0, \dots, j + readingOffset - 1\} \text{ and } B[k][i + offset] \text{ and } B[k][j + readingOffset]\}$
                            \State $intersect \gets []$ % \Comment{intersect is the set of indices of rows of A that have a 1 in both columns $i + offset$ and $j + readingOffset$}
                            \For {$k \gets 0$ to $j + readingOffset - 1$}
                                \If {$B[k][i + offset] = 1 \text{ and } B[k][j + readingOffset] = 1$}
                                    % \State $intersect \gets intersect \cup \{k\}$
                                    \State \Call{append}{$intersect, k$}
                                \EndIf
                            \EndFor
                            \If {$intersect \neq \emptyset$}
                                \State $kA \gets \Call{GetSpecificRowsFromA}{filename, intersect}$
                                \State \Call{Explore}{$I$, $U$, $intersect$, $COV$, $kA$, $B$, $offset$}
                            \EndIf
                        \EndIf
                    \EndIf
                \EndFor
            \EndWhile   
        \EndFunction         
    \end{algorithmic}
\end{frame}

\begin{frame}{}
    \scriptsize
    \begin{algorithmic}
        \Function{Explore}{$I$, $U$, $intersect$, $COV$, $kA$, $B$, $offset$}
            % \State $kN \gets \Call{rows}{kA}$
            % \State $kM \gets \Call{columns}{kA}$
            % \State $B[k][i + offset] \gets 0$
            \For {$k \in intersect$}
                \State $Itmp \gets I \cup \{(k)\}$
                \State $kRow \gets kA[k]$
                \State $Utmp \gets \Call{union}{U, kRow}$
                \If {$\Call{sum}{Utmp} == M$}
                    \State $COV \gets COV \cup \{Itmp\}$
                \Else {}
                    \State $intersectTmp \gets \{l \mid l \in intersect \text{ and } l<k \text{ and } B[l][k]\}$
                    \If {$intersectTmp \neq \emptyset$}
                        \State \Call{Explore}{$Itmp$, $Utmp$, $intersectTmp$, $COV$, $kA$, $B$, $offset$}
                    \EndIf
                \EndIf
            \EndFor
        \EndFunction
    \end{algorithmic}
\end{frame}


\begin{frame}{}
    \begin{figure}
        \centering
        \includegraphics[width=0.75\textwidth]{partial_loading_mech.pdf}
        \label{fig:partial_loading_mech}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_black.pdf}
        % \caption{}
        \label{fig:grid_black}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|}
            \hline
            Offset & Reading offset \\
            \hline
            0 & 0 \\
            \hline
        \end{tabular}
    \end{table}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_3r_1.pdf}
        % \caption{}
        \label{fig:grid_3r_1}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|}
            \hline
            Offset & Reading offset \\
            \hline
            0 & 0 \\
            \hline
        \end{tabular}
    \end{table}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_3r_1_ro_1.pdf}
        % \caption{}
        \label{fig:grid_3r_1_ro_1}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|}
            \hline
            Offset & Reading offset \\
            \hline
            3 & 0 \\
            \hline
        \end{tabular}
    \end{table}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_3r_2.pdf}
        % \caption{}
        \label{fig:grid_3r_2}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|}
            \hline
            Offset & Reading offset \\
            \hline
            3 & 0 \\
            \hline
        \end{tabular}
    \end{table}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_3r_2_ro_1.pdf}
        % \caption{}
        \label{fig:grid_3r_2_ro_1}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|}
            \hline
            Offset & Reading offset \\
            \hline
            3 & 3 \\
            \hline
        \end{tabular}
    \end{table}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_3r_2_ro_2.pdf}
        % \caption{}
        \label{fig:grid_3r_2_ro_2}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|}
            \hline
            Offset & Reading offset \\
            \hline
            6 & 0 \\
            \hline
        \end{tabular}
    \end{table}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_3r_3.pdf}
        % \caption{}
        \label{fig:grid_3r_3}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|}
            \hline
            Offset & Reading offset \\
            \hline
            6 & 0 \\
            \hline
        \end{tabular}
    \end{table}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_3r_3_ro_1.pdf}
        % \caption{}
        \label{fig:grid_3r_3_ro_1}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|}
            \hline
            Offset & Reading offset \\
            \hline
            6 & 3 \\
            \hline
        \end{tabular}
    \end{table}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_3r_3_ro_2.pdf}
        % \caption{}
        \label{fig:grid_3r_3_ro_2}
    \end{figure}
\end{frame}

\begin{frame}{}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|}
            \hline
            Offset & Reading offset \\
            \hline
            6 & 6 \\
            \hline
        \end{tabular}
    \end{table}
    \begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{grid_3r_3_ro_3.pdf}
        % \caption{}
        \label{fig:grid_3r_3_ro_3}
    \end{figure}
\end{frame}


\begin{frame}{Sudoku \footnote[frame]{The following content is 
    taken from \url{http://www.ams.org/publicoutreach/feature-column/fcarc-kanoodle}}}
    Any instance of the sudoku problem can be mapped to an isntance of the exact cover problem.
    Independently of the size of the sudoku grid, which we call $N$ (where $N$ is the number
    of rows, the number of columns, the number of boxes and the number of possible
    elements to put in a cell), the exact cover problem will have 4 constraints:
    \begin{enumerate}
        \item every cell contains exactly one of the $N$ possible elements;
        \item every row has exactly one of the $N$ possible elements in each of its $N$ cells;
        \item every column has exactly one of the $N$ possible elements in each of its $N$ cells;
        \item every $N\times N$ box has exactly one of the $N$ possible elements in each of its $N$ cells.
    \end{enumerate}
\end{frame}

\begin{frame}
    % \scriptsize
    Each of these constraints maps to $N^2$ columns of the matrix $A$, that is to say,
    every set of the exact cover problem has $4\cdot N^2$ elements.
    The number of sets of the exact cover problem is $N^3$, where $N^2$ is the number of cells
    and $N$ is the number of possible elements to put in a cell.
    This is how a 1 is mapped in a row of $A$, where \\ 
    $r,c,n \in \{0,\dots,N-1\}$, $i \in \{0,\dots,4\cdot N^2-1\}$, \\
    $r$ is the row, \\
    $c$ is the column, \\
    $n$ is the element, \\
    $i$ is the index of the column of $A$:
\end{frame}
\begin{frame}    
    \begin{enumerate}
        \item a 1 in the $i$-th cell from the first $N^2$ cells of a row of $A$ means that
        the $r$-th row and $c$-th cell of the sudoku grid has been filled with an element, without specifying which one,
        where $i = r\cdot N + c$;
        \item a 1 in the $i$-th cell from the second $N^2$ cells of a row of $A$ means that
        the $r$-th row has been filled with the $n$-th element, where $i = N^2 + r\cdot N + n$;
        \item a 1 in the $i$-th cell from the third $N^2$ cells of a row of $A$ means that
        the $c$-th column has been filled with the $n$-th element, 
        where $i = 2\cdot N^2 + c\cdot N + n$;
        \item a 1 in the $i$-th cell from the fourth $N^2$ cells of a row of $A$ means that
        the $r$-th row has been filled with the $n$-th element,
        % floor(r/N^2) in latex is 
        where $i = 3\cdot N^2 + \left(\left\lfloor\frac{r}{\sqrt{N}}\right\rfloor \sqrt{N}
        + \left\lfloor\frac{c}{\sqrt{N}}\right\rfloor\right)\cdot N + n$.
    \end{enumerate}
\end{frame}
\begin{frame}{}
    In a sudoku problem there always are some numbers already written in the grid,
    the presence of the numbers make the problem easier to solve, this reflects on the 
    exact cover problem being easier to solve, the way it becomes easier to solve is that
    the number of sets to explore decreases. One possibility is to simply remove the 
    sets that correspond to the cells that already have a number written in them but,
    in order to be able to write an algorithm that maps the solution to the exact cover problem 
    back to the solution to the sudoku, it's easier to keep the sets and make them all 0s rows,
    we can do this because our algorithm ignores the only 0s rows, so it's like pruning the tree.
\end{frame}

\begin{frame}{}
    % CODE TO TRANSLATE INTO PSEUDOCODE
    % def sudoku_to_exact_cover(sudoku, N):
    % constraints = 4  # Cell, Row, Column, Box
    % cover_matrix = [[0] * (N * N * constraints) for _ in range(N * N * N)]
    % divider = int(N ** 0.5)
    % for r in range(N):
    %     for c in range(N):
    %         for n in range(N):
    %             # Calculate row index for cover_matrix
    %             idx = (r * N + c) * N + n
                
    %             # Cell constraint - first N^2 columns
    %             cover_matrix[idx][r * N + c] = 1

    %             # Row constraint - second N^2 columns
    %             cover_matrix[idx][N * N + r * N + n] = 1

    %             # Column constraint - third N^2 columns
    %             cover_matrix[idx][2 * N * N + c * N + n] = 1

    %             # Box constraint - last N^2 columns
    %             box_row = r // divider
    %             box_col = c // divider
    %             box_num = box_row * divider + box_col  # This has changed from 3 to 2 for 4x4 Sudoku
    %             cover_matrix[idx][3 * N * N + box_num * N + n] = 1
                
    % # Prune rows that conflict with given Sudoku puzzle
    % # by setting them to all zeros

    % rows_to_remove = []
    % for r in range(N):
    %     for c in range(N):
    %         num = sudoku[r * N + c]-1
    %         if num+1:
    %             start_idx = (r * N + c) * N
    %             for i in range(N):
    %                 if i != num:
    %                     rows_to_remove.append(start_idx + i)


    % for idx in sorted(rows_to_remove):
    %     # Setting the row to all zeros
    %     cover_matrix[idx] = [0] * (N * N * constraints)
                
    % return cover_matrix
    \
    \begin{algorithmic}
        \Function{SudokuToExactCover}{$sudoku[], N$}
            \Comment{$sudoku$ is an array of length $N^2$ containing the numbers written in the sudoku grid}
            \State $nConstraints \gets 4$
            \State $coverMatrix \gets \Call{zeros}{N^3, N^2\cdot nConstraints}$
            \State \Call{FillA}{coverMatrix, N}
            % \For{$r \gets 0$ to $N-1$}
            %     \For{$c \gets 0$ to $N-1$}
            %         \For{$n \gets 0$ to $N-1$}
            %             \State $idx \gets (r\cdot N + c)\cdot N + n$
            %             \State $coverMatrix[idx][r\cdot N + c] \gets 1$
            %             \State $coverMatrix[idx][N^2 + r\cdot N + n] \gets 1$
            %             \State $coverMatrix[idx][2\cdot N^2 + c\cdot N + n] \gets 1$
            %             \State $boxRow \gets \lfloor r / \sqrt{N} \rfloor$
            %             \State $boxCol \gets \lfloor c / \sqrt{N} \rfloor$
            %             \State $boxNum \gets boxRow\cdot \sqrt{N} + boxCol$
            %             \State $coverMatrix[idx][3\cdot N^2 + boxNum\cdot N + n] \gets 1$
            %         \EndFor
            %     \EndFor
            % \EndFor
            \State $rowsToRemove \gets \Call{set}{\emptyset}$
            \State \Call{PruneRows}{$rowsToRemove$, $sudoku$, $N$}
            % \For{$r \gets 0$ to $N-1$}
            %     \For{$c \gets 0$ to $N-1$}
            %         \State $symbol \gets sudoku[r\cdot N + c] - 1$ \Comment{Numbers in a sudoku 
            %         usually start from 1, but in the matrix A they start from 0}
            %         \If{$num$ is not \textbf{NULL}} \Comment{\textbf{NULL} means that the cell is empty}
            %             \State $startIdx \gets (r\cdot N + c)\cdot N$
            %             \For{$i \gets 0$ to $N-1$}
            %                 \If{$i \neq num$}
            %                     \State $rowsToRemove \gets rowsToRemove \cup \{startIdx + i\}$
            %                 \EndIf
            %             \EndFor
            %         \EndIf
            %     \EndFor
            % \EndFor
            \For{$idx \in rowsToRemove$}
                \State $coverMatrix[idx] \gets \Call{zeros}{N^2\cdot nConstraints}$
            \EndFor
            \State \Return $coverMatrix$
        \EndFunction
    \end{algorithmic}
\end{frame}

\begin{frame}{}
    \begin{algorithmic}
        \Function{FillA}{$coverMatrix$, $N$}
            \For{$r \gets 0$ to $N-1$}
                \For{$c \gets 0$ to $N-1$}
                    \For{$n \gets 0$ to $N-1$}
                        \State $idx \gets (r\cdot N + c)\cdot N + n$
                        \State $coverMatrix[idx][r\cdot N + c] \gets 1$
                        \State $coverMatrix[idx][N^2 + r\cdot N + n] \gets 1$
                        \State $coverMatrix[idx][2\cdot N^2 + c\cdot N + n] \gets 1$
                        \State $boxRow \gets \lfloor r / \sqrt{N} \rfloor$
                        \State $boxCol \gets \lfloor c / \sqrt{N} \rfloor$
                        \State $b \gets boxRow\cdot \sqrt{N} + boxCol$
                        \State $coverMatrix[idx][3\cdot N^2 + b\cdot N + n] \gets 1$
                    \EndFor
                \EndFor
            \EndFor
        \EndFunction
    \end{algorithmic}
\end{frame}

\begin{frame}{}
    \begin{algorithmic}
        \Function{PruneRows}{$rowsToRemove$, $sudoku$, $N$}
            \For{$r \gets 0$ to $N-1$}
                \For{$c \gets 0$ to $N-1$}
                    \State $symbol \gets sudoku[r\cdot N + c] - 1$ \Comment{Numbers in a sudoku 
                    usually start from 1, but in the matrix A they start from 0}
                    \If{$num$ is not \textbf{NULL}}
                        \State $startIdx \gets (r\cdot N + c)\cdot N$
                        \For{$i \gets 0$ to $N-1$}
                            \If{$i \neq num$}
                                \State $rowsToRemove \gets rowsToRemove \cup \{startIdx + i\}$
                            \EndIf
                        \EndFor
                    \EndIf
                \EndFor
            \EndFor
        \EndFunction
    \end{algorithmic}
\end{frame}

\begin{frame}{}
    % def exact_cover_solution_to_sudoku(partition, N):
    % solution = [[0] * N for _ in range(N)]
    
    % for idx in partition:
    %     r, c, n = idx // (N * N), (idx // N) % N, (idx % N) + 1
    %     solution[r][c] = n
        
    % return solution
    \begin{algorithmic}
        \Function{ExactCoverSolutionToSudoku}{$ecSolution[], N$}
            \State $sudokuSolution \gets \Call{zeros}{N, N}$
            \For{$idx \in ecSolution$}
                \State $r \gets \left\lfloor \frac{idx}{(N^2)} \right\rfloor$
                \State $c \gets \left\lfloor (\frac{idx}{N}) \mod N \right\rfloor$
                \State $n \gets (idx \mod N) + 1$
                \State $sudokuSolution[r][c] \gets n$
            \EndFor
            \State \Return $sudokuSolution$
        \EndFunction
    \end{algorithmic}
\end{frame}

\begin{frame}{Generating Exact Cover problems}
    Having a module that generates exact cover problems given the 
    number of sets and the cardinality of the domain of the sets is
    useful for testing purposes.
    The idea of my choice to generate the exact cover problem is to ensure
    that the problem has at least a solution (that is, at least a set 
    of sets that cover all the elements of the domain creating a partition),
    this is done by setting randomly $M$ rows of the matrix $A$ to 
    the canonical base of $\mathbb{R}^M$.
    The precondition for this is that $N \geq M$.
    The rows of the matrix $A$ that are not set to the canonical base
    are set randomly, each of their $M$ cells is set to 1 or 0 with
    a custom probability, the default one is $p=0.5$.
\end{frame}

\begin{frame}{}
    \begin{algorithmic}
        \Function{GenerateExactCover}{$N$, $M$}
            \If {$N < M$}
                \State \Return \textbf{NULL}
            \EndIf
            \State $A \gets \Call{zeros}{N, M}$
            % # Choose a solution
            % selected_rows = random.sample(range(N), M)
            % for i, row in enumerate(selected_rows):
            %     matrix[row][i] = 1            
            \State $idxCanonicalBase[] \gets \Call{RandomSample}{\{0,\dots,N-1\}, M}$ 
            \Comment{Sample from $\{0,\dots,N-1\}$ without replacement for $M$ times}
            \For{$i \gets 0$ to $M-1$}
                \State $A[idxCanonicalBase[i]][i] \gets 1$
            \EndFor

            % # Add noise to remaining rows
            % for i in range(N):
            %     if i not in selected_rows:
            %         for j in range(M):
            %             matrix[i][j] = random.choice([0, 1])  
            \For{$i \gets 0$ to $N-1$}
                \If{$i \notin idxCanonicalBase$}
                    \For{$j \gets 0$ to $M-1$}
                        \State $A[i][j] \gets \Call{RandomChoice}{\{0,1\}}$
                    \EndFor
                \EndIf
            \EndFor
            \State \Return $A$
        \EndFunction
    \end{algorithmic}
\end{frame}          

\end{document}